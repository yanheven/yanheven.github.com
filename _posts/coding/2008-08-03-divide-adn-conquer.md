---
layout: post
title: 分治算法
category: coding
description: 分治算法

---

Author:[Hyphen](http://weibo.com/344736086)


分治算法

##### 一、分治算法

分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。

分治法解题的一般步骤：

（1）分解，将要解决的问题划分成若干规模较小的同类问题；

（2）求解，当子问题划分得足够小时，用较简单的方法解决；

（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。

当我们求解某些问题时，由于这些问题要处理的数据相当多，或求解过程相当复杂，使得直接求解法在时间上相当长，或者根本无法直接求出。对于这类问题，我们往往先把它分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。如果这些子问题还较大，难以解决，可以再把它们分成几个更小的子问题，以此类推，直至可以直接求出解为止。这就是分治策略的基本思想。下面通过实例加以说明。

【例】在n个元素中找出最大元素和最小元素。我们可以把这n个元素放在一个数组中，用直接比较法求出。算法如下：


```
void maxmin1(int A[],int n,int *max,int *min)

{ int i;

  *min=*max=A[0];

  for(i=2;i < n;i++)

  {  if(A > *max) *max= A;

     if(A < *min) *min= A;

  }

}
```

上面这个算法需比较2(n-1)次。能否找到更好的算法呢？我们用分治策略来讨论。

把n个元素分成两组：

A1={A[1],...,A[int(n/2)]}和A2={A[INT(N/2)+1],...,A[N]}

分别求这两组的最大值和最小值，然后分别将这两组的最大值和最小值相比较，求出全部元素的最大值和最小值。如果A1和A2中的元素多于两个，则再用上述方法各分为两个子集。直至子集中元素至多两个元素为止。

例如有下面一组元素：-13，13，9，-5，7，23，0，15。用分治策略比较的过程如下：

图中每个方框中，左边是最小值，右边是最大值。从图中看出，用这种方法一共比较了10次，比直接比较法的14次减少4次，即约减少了1/3。算法如下：

```
void  maxmin2(int A[],int i,int j,int *max,int *min)

/*A存放输入的数据，i，j存放数据的范围，初值为0，n-1，*max,int *min 存放最大和最小值*/

{ int mid,max1,max2,min1,min2;

  if (j==i) {最大和最小值为同一个数;return;}

  if (j-1==i) {将两个数直接比较，求得最大会最小值；return；}

  mid=(i+j)/2;

  求i~mid之间的最大最小值分别为max1，min1;

求mid+1~j之间的最大最小值分别为max2，min2;

  比较max1和max2，大的就是最大值;

比较min1和min2，小的就是最小值;

}
```

利用分治策略求解时，所需时间取决于分解后子问题的个数、子问题的规模大小等因素，而二分法，由于其划分的简单和均匀的特点，是经常采用的一种有效的方法，例如二分法检索。运用分治策略解决的问题一般来说具有以下特点：

1、原问题可以分解为多个子问题，这些子问题与原问题相比，只是问题的规模有所降低，其结构和求解方法与原问题相同或相似。

2、原问题在分解过程中，递归地求解子问题，由于递归都必须有一个终止条件，因此，当分解后的子问题规模足够小时，应能够直接求解。

3、在求解并得到各个子问题的解后，应能够采用某种方式、方法合并或构造出原问题的解。

不难发现，在分治策略中，由于子问题与原问题在结构和解法是的相似性，用分治方法解决的问题，大都采用了递归的形式。在各种排序方法中，如归并排序、堆排序、快速排序等，都存在有分治的思想。